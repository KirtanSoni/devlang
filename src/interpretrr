eval_procedure(proc(X), EnvIn, EnvOut) --> eval_block(X, EnvIn, EnvOut).
eval_block(blk(X), EnvIn, EnvOut) --> eval_statement_pipeline(X, EnvIn, EnvOut).
eval_statement_pipeline(stmt_pipe(X,Z), EnvIn, EnvOut) --> eval_statement(X, EnvIn, EnvIn1), eval_statement_pipeline(Z, EnvIn1, EnvOut).  
eval_statement_pipeline(stmt_pipe(X), , EnvIn, EnvOut) --> eval_statement(X, EnvIn, EnvOut).

% Data Types
eval_data_type(data_type_structure(X), EnvIn, EnvOut) --> eval_bool(X, EnvIn, EnvOut). 
eval_data_type(data_type_structure(X), EnvIn, EnvOut) --> eval_int(X, EnvIn, EnvOut). 
eval_data_type(data_type_structure(X), EnvIn, EnvOut) --> eval_charr(X, EnvIn, EnvOut). 

    % Boolean Data type 
    eval_bool(bool_structure(X), EnvIn, EnvOut) --> eval_bool_val(X, EnvIn, EnvOut). 
    eval_bool(bool_structure(X), EnvIn, EnvOut) --> eval_conditional_logic(X, EnvIn, EnvOut).

    % literals
    eval_bool_val(boolean(true), EnvIn, EnvOut).
    eval_bool_val(boolean(false), EnvIn, EnvOut).

        % Conditional Expressions.
        eval_conditional_logic(cond_log(X), EnvIn, EnvOut) --> eval_logical_comparison(X, EnvIn, EnvOut).
        eval_conditional_logic(cond_log(X), EnvIn, EnvOut) --> eval_integer_comparison(X, EnvIn, EnvOut). 
        eval_boolean_part(bool_part(X), EnvIn, EnvOut) --> eval_bool(X, EnvIn, EnvOut). 
		%TODO
        eval_boolean_part(bool_part(X), EnvIn, EnvOut) --> eval_variable(X, EnvIn, EnvOut),{bool(X)}.

            % And, Or, Not Gates TODO ADD SUPPORT FOR VAR
            eval_logical_comparison(log_comp(X,Z), EnvIn, EnvOut) --> eval_boolean_part(X, EnvIn, EnvIn1), eval_boolean_part(Z, EnvIn1, EnvOut).
            eval_logical_comparison(log_comp(X,Z), EnvIn, EnvOut) --> eval_boolean_part(X, EnvIn, EnvIn1), eval_boolean_part(Z, EnvIn1, EnvOut).
            eval_logical_comparison(log_comp(X), EnvIn, EnvOut) --> eval_boolean_part(X, EnvIn, EnvOut).
            % integer comparison
            eval_integer_comparison(int_comp(X,Y,Z), EnvIn, EnvOut) --> eval_int(X, EnvIn, EnvIn1), eval_comparison_operator(Y, EnvIn1, EnvIn2), eval_int(Z, EnvIn2, EnvOut).
                % Comparison Operator
                eval_comparison_operator(comp_op(>)). 
                eval_comparison_operator(comp_op(<)).
                eval_comparison_operator(comp_op(=)).


    % Integer Defination  % Loop ( remove loop )
    eval_int(int_structure(X), EnvIn, EnvOut) --> eval_numbers(X, EnvIn, EnvOut). 
    eval_int(int_structure(X), EnvIn, EnvOut) --> eval_expression(X, EnvIn, EnvOut).
    % literals
	%TODO
    eval_numbers(num(N_str)) --> [N_str], {  re_match("^[0-9]+$", N_str)}.
        % arithematic Expression ( interger functions )
        eval_expression_part(expr_part(X), EnvIn, EnvOut) --> eval_int(X, EnvIn, EnvOut). 
		%TODO
        eval_expression_part(expr_part(X)) --> eval_variable(X, EnvIn, EnvOut),{int(X)}.
        eval_expression(expr(X,Y,Z), EnvIn, EnvOut) --> eval_expression_part(X, EnvIn, EnvIn1), eval_operator(Y, EnvIn1, EnvIn2), eval_expression_part(Z,, EnvIn2, EnvOut).
        % Operator
            eval_operator(op(+)). 
            eval_operator(op(-)). 
            eval_operator(op(*)). 
            eval_operator(op(/)).

    % String ( character Array )
    eval_charr(char(X), EnvIn, EnvOut) --> eval_string(X, EnvIn, EnvOut).
        %literals
		%TODO
        eval_string(str(X)) --> {re_match("^[A-Za-z0-9]*$", X)}.

% Statement types
eval_statement(stmt(X), EnvIn, EnvOut) --> eval_null_statements(X, EnvIn, EnvOut).
eval_statement(stmt(X), EnvIn, EnvOut) --> eval_print_statements(X, EnvIn, EnvOut).
eval_statement(stmt(X), EnvIn, EnvOut) --> eval_assignment_statement(X, EnvIn, EnvOut).
eval_statement(stmt(X), EnvIn, EnvOut) --> eval_conditional_statement(X, EnvIn, EnvOut).
eval_statement(stmt(X), EnvIn, EnvOut) --> eval_loops(X, EnvIn, EnvOut).

    %   Null Statements
	%TODO:
    eval_null_statements(nul_state(), EnvIn, EnvOut).

    %  Print Statements
    eval_print_statements(print_stmt(X), EnvIn, EnvOut) --> eval_data_type(X, EnvIn, EnvOut).
    eval_print_statements(print_stmt(X), EnvIn, EnvOut) -->  eval_variable(X, EnvIn, EnvOut).

    % assignment Statements 
    eval_assignment_statement(assign_stmt(X,Z), EnvIn, EnvOut) --> eval_variable(X, EnvIn, EnvIn1), eval_data_type(Z, EnvIn1, EnvOut). 
        % Variable 
		%TODO
        eval_variable(variable_structure(I), EnvIn, EnvOut) --> [I], {re_match("^[a-z]+$", I)}.

    % Conditional Statements
    eval_conditional_statement(cond_stmt(X,Y,Z), EnvIn, EnvOut) --> eval_bool(X, EnvIn, EnvIn1), eval_block(Y,EnvIn1, EnvIn2), eval_block(Z, EnvIn2, EnvOut).
    eval_conditional_statement(cond_stmt(X,Y,Z), EnvIn, EnvOut) --> eval_bool(X, EnvIn, EnvIn1), eval_statement_pipeline(Y, EnvIn1, EnvIn2), eval_statement_pipeline(Z, EnvIn2, EnvOut).

    % Loops
    eval_loops(loops(X,Y), EnvIn, EnvOut) --> eval_loop_part(X, EnvIn, EnvIn1), eval_block(Y, EnvIn1, EnvOut). 
    eval_loops(loops(X,Y), EnvIn, EnvOut) --> eval_loopwith_part(X, EnvIn, EnvIn1), eval_block(Y, EnvIn1, EnvOut). 
    eval_loops(loops(X,Y), EnvIn, EnvOut) --> eval_looprange_part(X, EnvIn, EnvIn1), eval_block(Y, EnvIn1, EnvOut).
        % while loop
        eval_loop_part(loop_part(X), EnvIn, EnvOut) --> eval_conditional_logic(X, EnvIn, EnvOut).
        % for loop
        eval_loopwith_part(loop_with(X,Y), EnvIn, EnvOut) --> eval_assignment_statement(X, EnvIn, EnvIn1), eval_conditional_logic(Y, EnvIn1, EnvOut).
        % range loop
        eval_looprange_part(loop_range(X,Z), EnvIn, EnvOut) --> eval_assignment_statement(X, EnvIn, EnvIn1),  eval_int(Z, EnvIn1, EnvOut).

update(Key, Val, [], [(Key, Val)]).
update(Key, Val, [(Key, _)|Tail], [(Key, Val)|Tail]).
update(Key, Val, [(Key1, Val1) | Tail], [(Key1, Val1)| Env1]) :- Key \= Key1, update(Key, Val, Tail, Env1).

lookup(Key, [(Key, Val)|_], Val).
lookup(Key, [(Key1, _)|Tail], Val) :- Key1 \= Key, lookup(Key, Tail, Val).
